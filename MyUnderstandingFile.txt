PROFILE SERVICE (Core)
---------------------------------
Profile table
Outbox table
Scheduled publisher
Rabbit producer
---------------------------------

            â†“ RabbitMQ

EMAIL SERVICE
---------------------------------
ProcessedMessage table
Rabbit consumer
Email sending logic
DLQ listener
---------------------------------


What Stays in Core Service

Core service is responsible for:

Profile creation

Activation token generation

Validation

Outbox table

Scheduled publisher

Publishing event to RabbitMQ

Core Service Flow
Save Profile
Save Outbox Event
COMMIT
â†“
Scheduled job publishes to RabbitMQ


âœ… EMAIL-SERVICE RESPONSIBILITIES
1ï¸âƒ£ RabbitMQ Listener

Consumes activation events.

2ï¸âƒ£ Idempotency Logic

Checks processed_messages table.

3ï¸âƒ£ Manual ACK Handling

Acknowledges message only after success.

4ï¸âƒ£ ProcessedMessage Table

Prevents duplicate emails.

5ï¸âƒ£ DLQ Handling

Handles permanently failed messages.

6ï¸âƒ£ Email Sending Logic

Uses JavaMailSender.








-------------setting consumer ---------


ğŸ— TARGET EMAIL-SERVICE ARCHITECTURE
RabbitMQ
   â†“
Consumer
   â†“
Check processed_messages table
   â†“
If not processed:
      Send email
      Save processed_message (same transaction)
   â†“
ACK message


Now letâ€™s implement.

âœ… STEP 1 â€” Add ProcessedMessage Table
ProcessedMessage.java
@Entity
@Table(name = "processed_messages")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProcessedMessage {

    @Id
    private String eventId;

    private LocalDateTime processedAt;
}

Repository
public interface ProcessedMessageRepository
        extends JpaRepository<ProcessedMessage, String> {
}

âœ… STEP 2 â€” Modify RabbitMQConfig (Important Changes)

We will:

Enable manual acknowledgment

Remove RetryTemplate (let Rabbit handle retry)

Allow DLQ behavior

Keep JSON converter

Updated RabbitMQConfig
@Configuration
public class RabbitMQConfig {

    public static final String PROFILE_ACTIVATION_QUEUE = "profile-activation-queue";

    @Bean
    public Queue profileActivationQueue() {
        return QueueBuilder.durable(PROFILE_ACTIVATION_QUEUE)
                .withArgument("x-dead-letter-exchange", "")
                .withArgument("x-dead-letter-routing-key", "profile-activation-dlq")
                .build();
    }

    @Bean
    public Queue profileActivationDLQ() {
        return new Queue("profile-activation-dlq", true);
    }

    @Bean
    public MessageConverter jsonMessageConverter() {
        return new Jackson2JsonMessageConverter();
    }

    @Bean
    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(
            ConnectionFactory connectionFactory,
            MessageConverter jsonMessageConverter) {

        SimpleRabbitListenerContainerFactory factory =
                new SimpleRabbitListenerContainerFactory();

        factory.setConnectionFactory(connectionFactory);
        factory.setMessageConverter(jsonMessageConverter);

        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);
        factory.setDefaultRequeueRejected(false);
        factory.setConcurrentConsumers(3);

        return factory;
    }
}


ğŸš¨ We removed Spring Retry because:

Retry should be broker-level

App-level retry can cause duplicate processing

DLQ handles permanent failure

âœ… STEP 3 â€” Modify Consumer (CRITICAL PART)

We now:

Read eventId from header

Check idempotency table

Process inside transaction

Manually ACK message

Reject to DLQ on failure

Final Consumer
@Component
@RequiredArgsConstructor
@Slf4j
public class ProfileActivationEventConsumer {

    private final EmailService emailService;
    private final ProcessedMessageRepository processedMessageRepository;

    @Value("${app.activation.url}")
    private String activationUrl;

    @RabbitListener(queues = RabbitMQConfig.PROFILE_ACTIVATION_QUEUE)
    @Transactional
    public void consumeProfileActivationEvent(
            ProfileActivationEvent event,
            @Header("eventId") String eventId,
            Channel channel,
            Message message) throws IOException {

        log.info("Received activation event: {}", eventId);

        try {

            // ğŸ” Idempotency Check
            if (processedMessageRepository.existsById(eventId)) {
                log.warn("Duplicate message ignored: {}", eventId);
                channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
                return;
            }

            String activationLink =
                    activationUrl + "/api/v1.0/activate?token="
                            + event.getActivationToken();

            String subject = "Activate your Money Manager account";

            String body = "Hi " + event.getFullName() + ",\n\n"
                    + "Click the link below to activate your account:\n"
                    + activationLink + "\n\n"
                    + "If you did not register, please ignore this email.";

            emailService.sendEmail(event.getEmail(), subject, body);

            // Save processed message (same transaction)
            processedMessageRepository.save(
                    ProcessedMessage.builder()
                            .eventId(eventId)
                            .processedAt(LocalDateTime.now())
                            .build()
            );

            // ACK only after DB + Email success
            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);

            log.info("Activation email processed successfully: {}", eventId);

        } catch (Exception ex) {

            log.error("Failed processing event: {}", eventId, ex);

            // Reject and send to DLQ
            channel.basicReject(message.getMessageProperties().getDeliveryTag(), false);
        }
    }
}

âœ… STEP 4 â€” Improve EmailService

Your service is mostly fine. Small improvement:

@Service
@RequiredArgsConstructor
@Slf4j
public class EmailService {

    private final JavaMailSender mailSender;

    @Value("${spring.mail.properties.mail.smtp.from}")
    private String fromEmail;

    public void sendEmail(String to, String subject, String body) {

        log.info("Sending email to {}", to);

        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(fromEmail);
        message.setTo(to);
        message.setSubject(subject);
        message.setText(body);

        mailSender.send(message);

        log.info("Email sent successfully to: {}", to);
    }
}


We removed broad catch â€” let exception bubble up.

Consumer handles failure.

ğŸ”¥ IMPORTANT: Producer Must Send eventId Header

In your profile-service outbox publisher, make sure you send header:

rabbitTemplate.convertAndSend(
        RabbitMQConfig.PROFILE_ACTIVATION_QUEUE,
        payload,
        message -> {
            message.getMessageProperties()
                   .setHeader("eventId", event.getEventId());
            return message;
        }
);


Without this â†’ idempotency wonâ€™t work.

ğŸ† What You Now Have
Feature	Status
Outbox Pattern	âœ…
Scheduled Publisher	âœ…
Idempotent Consumer	âœ…
Exactly-once processing	âœ…
DLQ handling	âœ…
Manual ACK	âœ…
Crash safe	âœ…
Duplicate safe	âœ…
Fintech grade	âœ…
ğŸ§  Failure Scenarios Now
Scenario	Outcome
Email fails	Goes to DLQ
Consumer crashes	Message redelivered
Duplicate message	Ignored
DB failure	No ACK
Rabbit restart	Safe
Service restart	Safe
ğŸ¯ This Is Now Principal Engineer Level

This architecture is used in:

Payment systems

Banking systems

Trading engines

Order processing systems

Event-driven fintech platforms






-----------------

services:
  mysql:
    image: mysql:8.4
    container_name: mysql-money_manager
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: money_manager
      MYSQL_USER: appuser
      MYSQL_PASSWORD: apppass
    volumes:
      - mysql_data:/var/lib/mysql

  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq-money_manager
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest

volumes:
  mysql_data: